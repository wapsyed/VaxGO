---
title: "VaxGO"
author: "Wasim Syed (@wasimvacinas)"
output: 
  flexdashboard::flex_dashboard:
    logo: "vaxgo_logo_40.png"
    orientation: columns
    theme:
      bg: "#ffffff"
      fg: "#000000" 
      primary: "#ffffff"
      base_font:
        google: Montserrat
      code_font:
        google: Montserrat
    source_code: embed 
    navbar:
        - { icon: "fa-instagram", href: "https://instagram.com/wasimvacinas", align: right}
        - { icon: "fa-linkedin", href: "https://www.linkedin.com/in/wapsyed", align: right}
        - { icon: "ion-github", href: "github.com/wapsyed", align: right}
runtime: shiny
---

<style>
  body {
    font-size: 15px;
  }
  
  .form-group,
  .shiny-input-container {
    font-size: 15px; 
  }
  
  .shiny-input-container input,
  .shiny-input-container select,
  .shiny-input-container textarea {
    font-size: 15px;
  }
  .btn,
  .btn-primary {
    font-size: 15px; 
  }
  
  .table,
  .table th,
  .table td {
    font-size: 12px; 
  }
</style>

```{r setup, include=FALSE}
# Install packages ------
# install.packages("flexdashboard")
# install.packages("datasets")
# install.packages("knitr")
# devtools::install_github("rstudio/d3heatmap")
# install_github("jokergoo/InteractiveComplexHeatmap")
# install.packages("biclust")
# install.packages("BH")
# install.packages('heatmaply')
# install.packages("devtools")
# Bioconductor packages ------------------------
# install.packages("BiocManager")
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# 
# BiocManager::install("GEOquery")
# BiocManager::install("DESeq2")
# BiocManager::install("biomaRt")
# BiocManager::install("celldex")
# BiocManager::install("GSVA")
# BiocManager::install("sva")
# BiocManager::install("clusterProfiler")
# BiocManager::install("msigdbr")
# BiocManager::install("EnhancedVolcano")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("ComplexHeatmap")
# BiocManager::install("InteractiveComplexHeatmap")
# BiocManager::install("cytolib")
# BiocManager::install("ImmuneSpaceR")
# BiocManager::install("org.Hs.eg.db", character.only = TRUE)

# Call library ------
library(BiocManager)
library(devtools)
library(GEOquery)
library(Matrix)
library(circlize)
library(RColorBrewer)
library(celldex)
library(biomaRt)
library(org.Hs.eg.db)
library(plotly)
library(DESeq2)
library(msigdbr)
library(ape)
library(GSVA)
library(sva)
library(clusterProfiler)
library(EnhancedVolcano)
library(ggbeeswarm)
library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(factoextra)
library(esquisse)
library(ComplexHeatmap)
library(janitor)
library(ggsci)
library(patchwork)
library(ggthemes)
library(here)
library(extrafont)
library(showtext)
library(readxl)
library(scales)
library(tidyverse)
library(flexdashboard)
library(ggheatmap)
library(vegan)
library(InteractiveComplexHeatmap)
library(corto)
library(ggstatsplot)
# library(ImmuneSpaceR)
library(plotly)
library(flexdashboard)
library(datasets)
library(InteractiveComplexHeatmap)
library(biclust)
library(datasets)
library(DT)
library(ggthemes)
library(here)
library(tidyverse)
library(dplyr)
library(org.Hs.eg.db)
library(BH)
library(tidyverse)
library(cytolib)
library(heatmaply)


#Increaze upload file size
options(shiny.maxRequestSize=30*1024^2)

```

# DEGs analysis


```{r eval=FALSE, include=FALSE}
#Example data
example_condition = read_csv(here("Example","all_degs_p_05_vac_infected_19_12_23.csv")) %>% 
  filter(condition == "BNT (V2, D1)")

example_condition %>% 
  write_csv(file = here("Example", "Example_DEGs_BNT_V2_D1.csv"))

example_conditions = read_csv(here("Example","all_degs_p_05_vac_infected_19_12_23.csv")) %>% 
  filter(vaccine == "BNT",
         regimen == "HO",
         disease_vac == "V",
         infection == 0)

example_conditions %>% 
  write_csv(file = here("Example", "Example_DEGs_BNT_multiple.csv"))


example_conditions_allBNT = read_csv(here("Example","all_degs_p_05_vac_infected_19_12_23.csv")) %>% 
  filter(vaccine == "BNT")
example_conditions_allBNT %>% 
  write_csv(file = here("Example", "Example_DEGs_BNT_AllBNTs.csv"))
```



## Column {.sidebar data-width=300}


**Upload your data**

```{r}
#INPUTS

#https://shiny.posit.co/r/gallery/widgets/widget-gallery/ 

############## Upload files ############## 

textInput(inputId = "filename", 
          label = "Project title", 
          value = "my_condition_degs")


fileInput(inputId = "conditions_genes", 
          label = "DEGs L2FC",
           accept = ".csv")


fileInput(inputId = "annotation_conditions", 
          label = "Condition annotations",
           accept = ".csv")
```

**Select annotations**
```{r}
checkboxGroupInput(inputId = "columns_annotation", 
                   label = "Annotations", 
                   choices = NULL)

# Reactive expression to read the uploaded file
annotations <- reactive({
  req(input$annotation_conditions)
  read.csv(input$annotation_conditions$datapath)
})

# Observe the file input and update the checkbox group choices
observe({
  req(annotations())
  updateCheckboxGroupInput(session, "columns_annotation",
                           choices = names(annotations()))
})

tableOutput("selected_columns")
```

**Filters**
```{r}
############## Filters 

# DGE analysis
numericInput(inputId = "filter_padj", 
             label = "Adjusted p-value cutoff", 
             value = 0.05, 
             min = 0, max = 1, step = 0.01)

numericInput(inputId = "filter_logfc", 
             label = "Log2 Fold Change cutoff", 
             value = 1, 
             min = 0, max = 10, step = 0.1)

actionButton("go_1", "Go")

```

## Row {.tabset .tabset-fade}

### Volcano plot

```{r}

renderPlotly({
  req(input$go_1) # Action button
  req(conditions_genes())
  
  # Prepare the data
  data <- conditions_genes() %>%
    mutate(log_q = -log10(padj))
  
  # List of unique conditions
  unique_conditions <- unique(data$condition)
  
  # Create an empty plot
  p <- plot_ly()
  
  # Add a trace for each condition
  for (cond in unique_conditions) {
    p <- p %>%
      add_trace(
        data = data[data$condition == cond, ],
        x = ~log2fold_change, 
        y = ~log_q, 
        text = ~genes,
        type = 'scatter', 
        mode = 'markers',
        marker = list(
          color = ~log2fold_change,
          size = 10,
          opacity = 0.9,
          colorscale = c("#3399FF", "white", "#FF6666")
        ),
        name = cond,
        visible = ifelse(cond == unique_conditions[1], TRUE, FALSE) # Show only the first condition by default
      )
  }
  
  # Create updatemenus based on conditions
  condition_buttons <- lapply(1:length(unique_conditions), function(i) {
    visibility <- rep(FALSE, length(unique_conditions))
    visibility[i] <- TRUE
    list(
      method = "restyle",
      args = list("visible", visibility),
      label = unique_conditions[i]
    )
  })
  
  # Add layout options including the update menus
  p %>%
    layout(
      title = "Volcano Plot",
      xaxis = list(title = "Log2 Fold Change"),
      yaxis = list(title = "-Log10 Adjusted P-value"),
      updatemenus = list(
        list(
          y = 1,  # Position the buttons near the top
          x = 0,   # Center the buttons horizontally
          xanchor = "center",
          yanchor = "top",
          buttons = condition_buttons,
          showactive = TRUE
        )
      )
    )
})
```

### Bar plot
```{r}
renderPlotly({
    req(input$go_1) # Action button
  req(conditions_genes())
  
  # Prepare the data
  data <- conditions_genes()  %>%
        filter(direction != "NEUTRAL",
           log2fold_change >= input$filter_logfc | log2fold_change <= - input$filter_logfc,
           padj < input$filter_padj) %>% 
    group_by(condition, direction) %>% 
    summarize(n_direct = n()) %>% 
    ungroup()
    
  
  # Create the volcano plot directly with plotly
  plot_ly(data, 
        x = ~condition, 
        y = ~n_direct, 
        color = ~direction, 
        colors = c("#3399FF", "#FF6666"),
        text = ~direction,
        type = 'bar') %>%
  layout(
    title = "DEGs Counts",
    xaxis = list(title = "Condition"),
    yaxis = list(title = "# Genes"),
    barmode = 'group',  
    coloraxis = list(colorbar = list(title = 'Direction'))
  )
})

```


## Row

### Genes table

```{r}

# Reactive expression to load and process the file
conditions_genes <- reactive({
  req(input$conditions_genes)
  
  # Load the file
  conditions_genes <- read.csv(input$conditions_genes$datapath) %>% 
    distinct()
  conditions_genes
})

# Reactive expression to filter significant DEGs
degs_sig <- reactive({
  req(conditions_genes(), input$filter_padj)
  
  degs_sig <- conditions_genes() %>%
    filter(padj < input$filter_padj) %>% 
    distinct()
  
  degs_sig
})

# Reactive expression to further filter DEGs and extract gene names
genes <- reactive({
  req(degs_sig())
  
  genes <- degs_sig() %>%
    filter(direction != "NEUTRAL") %>%
    pull(genes)
  
  genes
})

DT::renderDataTable({
  req(input$go_1) # Action button
  req(degs_sig())
  
  # Define input values for the cutoffs
filter_l2fc <- input$filter_logfc
filter_neg_l2fc <- -input$filter_logfc
  
  # Transform the filtered data into a DataTable
degs_sig() %>%
  datatable(options = list(pageLength = 25)) %>%
  formatStyle(
    'log2fold_change',
    backgroundColor = styleInterval(
      c(filter_neg_l2fc, filter_l2fc),
      c('#3399FF', 'white', '#FF6666')
    ),
    fontWeight = 'bold'  # Optional: make the text bold for better visibility
  )
})

```


# Over representation analysis

## Column {.sidebar data-width=300}

```{r}
#ORA Parameters

# Tamanho mínimo e máximo do conjunto de genes (Gene Set Size)
numericInput(inputId = "minGSSize", 
             label = "Minimum Gene Set Size", 
             value = 1, 
             min = 1, max = 1000, step = 1)

numericInput(inputId = "maxGSSize", 
             label = "Maximum Gene Set Size", 
             value = 1000, 
             min = 1, max = 10000, step = 1)

# Multiple testing p-value adjustment method
selectInput(inputId = "pAdjustMethod", 
            label = "p-value Adjustment Method", 
            choices = c("BH", "BY", "fdr", "holm", "hochberg", "hommel", "bonferroni"),
            selected = "BH")

# Cutoffs ORA (Over-Representation Analysis)
numericInput(inputId = "pvalueCutoff_ora", 
             label = "ORA p-value Cutoff", 
             value = 0.05, 
             min = 0, max = 1, step = 0.01)

numericInput(inputId = "qvalueCutoff_ora", 
             label = "ORA q-value Cutoff", 
             value = 0.10, 
             min = 0, max = 1, step = 0.01)

# Multiple testing p-value adjustment method
selectInput(inputId = "organism", 
            label = "Organism", 
            choices = c("org.Hs.eg.db", "org.Mm.eg.db"),
            selected = "org.Hs.eg.db")


actionButton("go", "Go")

```

Please, be patient. Click once and wait. It may take a while.


## Column {.tabset .tabset-fade}

```{r}
# Load data ------

########## Gene sets ------

######## IMMUNEGO -----
ImmuneGO_Annotated_GO <- read_csv(here("Tables", "ImmuneGO_Annotated_GO_2024-05-28.csv"))

ImmuneGO_annotation = ImmuneGO_Annotated_GO %>% 
  dplyr::select(process, immune_system:immune_tissue) 

ImmuneGO_genes_general = ImmuneGO_Annotated_GO %>% 
  separate_rows(genes, sep = ",") %>% 
  filter(go_term == "Manual",
         !process %in% c("ADAPTIVE IMMUNE SYSTEM",
                         "INNATE IMMUNE SYSTEM",
                         "BCR REPERTOIRE",
                         "TCR REPERTOIRE")) %>% 
  dplyr::select(process, genes)

ImmuneGO_genes_specific = ImmuneGO_Annotated_GO %>% 
  separate_rows(genes, sep = ",") %>% 
  filter(!go_term == "Manual") %>% 
  dplyr::select(process=gene_set_short, genes)

######## CELL MARKER IMMUNE ---------

CellMarker_ImmuneCells = read_csv(here("Tables", "CellMarker_ImmuneCells.csv"))
CellMarker_annotation = CellMarker_ImmuneCells %>% 
  dplyr::select(cell_name, Type) %>% 
  distinct()

CellMarker_genes = CellMarker_ImmuneCells %>% 
  dplyr::select(process = cell_name, genes = marker)

######## VAX MSIGDB --------
VaxSigDB_Gene_sets_Annotated_RAW <- read_csv(here("Tables", "VaxSigDB_Gene_sets_Annotated_RAW.csv"))

#Filters
vaxsig_columns = c("VACCINE", "PLATFORM", "TARGET_PATHOGEN_DISEASE", "MICROBE_TYPE", "STUDY_TYPE", "STUDY_SUBTYPE","DATE-TIME", "DATE", "TIME", "AGE", "AGE_CATEGORY", "SAMPLE_SOURCE", "SYSTEMATIC_NAME", "GENE_SYMBOLS")
filter_vaxsig_samplesource = "PBMC"
filter_vaxsig_studytype = "VACCINE"
filter_vaxsig_studysubtype = "VAC ONLY"

VaxSigDB_Genesets_filtered = VaxSigDB_Gene_sets_Annotated_RAW %>% 
  dplyr::select(vaxsig_columns) %>% 
  filter(SAMPLE_SOURCE == filter_vaxsig_samplesource,
         STUDY_TYPE == filter_vaxsig_studytype,
         STUDY_SUBTYPE == filter_vaxsig_studysubtype) 
#Annotation
VaxSigDB_annotation = VaxSigDB_Genesets_filtered %>% 
  mutate(process = paste0(VACCINE, " (", `DATE-TIME`, ", ", AGE, " YO)")) %>% 
  dplyr::select(process, PLATFORM, TARGET_PATHOGEN_DISEASE, MICROBE_TYPE, DATE, TIME)
#Genes
VaxSigDB_Genes_filtered = VaxSigDB_Genesets_filtered %>% 
  separate_rows(GENE_SYMBOLS, sep = ",") %>% 
  mutate(process = paste0(VACCINE, " (", `DATE-TIME`, ", ", AGE, " YO)")) %>% 
  dplyr::select(process, genes = GENE_SYMBOLS)

######## BTM MODULES --------
btm_annotation_table <- read_csv(here("Tables", "btm_annotation_immune_table_labelled.csv"))

#Filters
filter_btm_category = "immune"
filter_btm_annotationlevel = c("complete", "partial") #Anyone
# filter_btm_annotationlevel = "complete"
# filter_btm_annotationlevel = "partial"

#Annotation
btm_annotation = btm_annotation_table %>% 
  filter(module_category == filter_btm_category,
         annotation_level %in% filter_btm_annotationlevel) %>% 
  dplyr::select(immune_system, immune_subsystem, cells, composite_name)
#Genes
btm_genes = btm_annotation_table %>% 
  filter(module_category == filter_btm_category,
         annotation_level %in% filter_btm_annotationlevel) %>% 
  dplyr::select(process = composite_name, genes = module_member_genes) %>% 
  separate_rows(genes, sep = ",")

#Vaccine Atlas TERMINAR -----
# study <- CreateConnection("IS2")
# 
# dataset <- study$getDataset("demographics", original_view = FALSE)
# VaxAtlas_all_norm_eset <- readRDS(here("Tables", "VaxAtlas_all_norm_eset.rds"))
```

### General ORA
```{r}
#### General Gene ontologies
# Filter non-neutral DEGs
# Reactive expression to filter non-neutral DEGs
df <- reactive({
  req(degs_sig())
  degs_sig() %>%
    filter(direction != "NEUTRAL")
})

# Compute GO enrichment results
ora_results_general <- reactive({
  
  req(input$go) #Action button
  
  req(df())
  
  results <- list()
  
  for (condition_2 in unique(df()$condition)) {
    genes <- df() %>%
      filter(condition == condition_2) %>%
      pull(genes)
    
    go_enrich <- tryCatch({
      enrichGO(gene = genes,
               OrgDb = input$organism, 
               keyType = 'SYMBOL',
               readable = TRUE,
               ont = "BP",
               pvalueCutoff = input$pvalueCutoff_ora, 
               qvalueCutoff = input$qvalueCutoff_ora) %>%
        as.data.frame() %>%
        mutate(condition = condition_2)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(go_enrich)) {
      results[[condition_2]] <- go_enrich   
    }
  }
  
  ora_results = bind_rows(results) %>%
    rownames_to_column("delete") %>%
    dplyr::select(-"delete") %>%
    clean_names() 
  
  ora_results
  
})

# Display the final results
DT::renderDataTable({
  req(input$go) # Action button
  req(ora_results_general())
  ora_results_general() %>% datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})

```

```{r include=FALSE}
# Function
autoORA <- function(df,
                    TERM2GENE,
                    pAdjustMethod, 
                    pvalueCutoff_ora, 
                    qvalueCutoff_ora,
                    geneset_name) {
  
  # Função interna para aplicar enricher a uma condição específica
  enricher_conditional <- function(condition_2, df, TERM2GENE, pAdjustMethod, pvalueCutoff_ora, qvalueCutoff_ora) {
    genes <- df %>% 
      filter(condition == condition_2) %>% 
      pull(genes)
    
    tryCatch({
      enricher(gene = genes,
               TERM2GENE = TERM2GENE,
               pAdjustMethod = pAdjustMethod,
               pvalueCutoff = pvalueCutoff_ora, 
               qvalueCutoff = qvalueCutoff_ora) %>% 
        as.data.frame() %>%
        mutate(condition = condition_2,
               geneset_name = geneset_name)
    }, error = function(e) {
      NULL
    })
  }
  
  # Aplicar a função interna a cada condição única e combinar os resultados
  ora_results <- df %>%
    distinct(condition) %>%
    pull(condition) %>%
    map_dfr(~ enricher_conditional(.x, df, TERM2GENE, pAdjustMethod, pvalueCutoff_ora, qvalueCutoff_ora))
  
  # Limpar os resultados finais
  ora_results_final <- ora_results %>%
    rownames_to_column("delete") %>%
    dplyr::select(-delete, -Description) %>%
    dplyr::select(condition, geneset_name, everything()) %>% 
    clean_names() %>% 
    rename(process = id)
  
  return(ora_results_final)
}
```

### ImmuneGO General
```{r}
# Reactive expression to perform ORA analyses
ora_results_ImmuneGO_General <- reactive({
  req(input$go)
  req(df())
  
  # Perform ORA for ImmuneGO general
  degs_ORA_ImmuneGO_General <- df() %>%
    autoORA(TERM2GENE = ImmuneGO_genes_general,
            geneset_name = "ImmuneGO General",
            pAdjustMethod = input$pAdjustMethod,
            pvalueCutoff_ora = input$pvalueCutoff_ora,
            qvalueCutoff_ora = input$qvalueCutoff_ora)
})

# Render the DataTable
renderDT({
  req(input$go)
  req(ora_results_ImmuneGO_General())
  ora_results_ImmuneGO_General() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```

### ImmuneGO specific
```{r}
# Reactive expression to perform ORA analyses
ora_results_ImmuneGO_specific <- reactive({
  req(input$go)
  req(df())
  
  # Perform ORA for ImmuneGO general
  degs_ORA_ImmuneGO_specific <- df() %>%
    autoORA(TERM2GENE = ImmuneGO_genes_specific,
            geneset_name = "ImmuneGO Specific",
            pAdjustMethod = input$pAdjustMethod,
            pvalueCutoff_ora = input$pvalueCutoff_ora,
            qvalueCutoff_ora = input$qvalueCutoff_ora)
})

# Render the DataTable
renderDT({
  req(input$go)
  req(ora_results_ImmuneGO_specific())
  ora_results_ImmuneGO_specific() %>% 
    datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```


### CellMarker immune
```{r}
# Reactive expression to perform ORA analyses
ora_results_Cellmarker_Immune <- reactive({
  req(input$go)
  req(df())
  
  # Perform ORA for ImmuneGO general
  degs_ORA_CellMarker_immune <- df() %>%
    autoORA(TERM2GENE = CellMarker_genes,
            geneset_name = "CellMarker Immune",
            pAdjustMethod = input$pAdjustMethod,
            pvalueCutoff_ora = input$pvalueCutoff_ora,
            qvalueCutoff_ora = input$qvalueCutoff_ora)
})

# Render the DataTable
renderDT({
  req(input$go)
  req(ora_results_Cellmarker_Immune())
  ora_results_Cellmarker_Immune() %>% 
    datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```

### BTM immune
```{r}
# Reactive expression to perform ORA analyses
ora_results_BTM_Immune <- reactive({
  req(input$go)
  req(df())
  
  # Perform ORA for ImmuneGO general
  degs_ORA_BTM_immune <- df() %>%
    autoORA(TERM2GENE = btm_genes,
            geneset_name = "BTM Immune",
            pAdjustMethod = input$pAdjustMethod,
            pvalueCutoff_ora = input$pvalueCutoff_ora,
            qvalueCutoff_ora = input$qvalueCutoff_ora)
})

# Render the DataTable
renderDT({
  req(input$go)
  req(ora_results_BTM_Immune())
  ora_results_BTM_Immune() %>% 
    datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```

### VAX MsigDB
```{r}
# Reactive expression to perform ORA analyses
ora_results_VAX_filtered <- reactive({
  req(input$go)
  req(df())
  
  # Perform ORA for ImmuneGO general
  degs_ORA_VAX_filtered <- df() %>%
    autoORA(TERM2GENE = VaxSigDB_Genes_filtered,
            geneset_name = "VAX SigDB filtered",
            pAdjustMethod = input$pAdjustMethod,
            pvalueCutoff_ora = input$pvalueCutoff_ora,
            qvalueCutoff_ora = input$qvalueCutoff_ora)
})

# Render the DataTable
renderDT({
  req(input$go)
  req(ora_results_VAX_filtered())
  ora_results_VAX_filtered() %>% 
    datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```


# GSEA

## Column {.sidebar data-width=300}
```{r}
#ORA Parameters

# Tamanho mínimo e máximo do conjunto de genes (Gene Set Size)
numericInput(inputId = "minGSSize", 
             label = "Minimum Gene Set Size", 
             value = 1, 
             min = 1, max = 1000, step = 1)

numericInput(inputId = "maxGSSize", 
             label = "Maximum Gene Set Size", 
             value = 1000, 
             min = 1, max = 10000, step = 1)

# Multiple testing p-value adjustment method
selectInput(inputId = "pAdjustMethod", 
            label = "p-value Adjustment Method", 
            choices = c("BH", "BY", "fdr", "holm", "hochberg", "hommel", "bonferroni"),
            selected = "BH")

# Cutoff GSEA
numericInput(inputId = "pvalueCutoff_gsea", 
             label = "GSEA p-value Cutoff", 
             value = 0.25, 
             min = 0, max = 1, step = 0.01)


# Multiple testing p-value adjustment method
selectInput(inputId = "organism", 
            label = "Organism", 
            choices = c("org.Hs.eg.db", "org.Mm.eg.db"),
            selected = "org.Hs.eg.db")

actionButton("go_2", "Go")


```

Please, be patient. It may take a while.

## Column {.tabset .tabset-fade}

```{r include=FALSE}
# Define the autoGSEA function
autoGSEA <- function(df, TERM2GENE, 
                     geneset_name, 
                     minGSSize, 
                     maxGSSize,
                     pvalueCutoff,
                     pAdjustMethod) {
  results <- list()
  
  condicoes <- df %>%
    dplyr::pull(condition) %>%
    unique() %>%
    as.character()
  
  for (condicao in condicoes) {
    degs_condicao <- df %>%
      dplyr::filter(condition == condicao) %>%
      dplyr::select(genes, log2fold_change) %>%
      distinct() %>%
      mutate(rank = rank(log2fold_change, ties.method = "random")) %>%
      arrange(desc(rank))
    
    gene_list_lf2c <- as.vector(degs_condicao$log2fold_change)
    names(gene_list_lf2c) <- degs_condicao$genes
    gene_list_lf2c <- na.omit(gene_list_lf2c)
    gene_list_lf2c <- sort(gene_list_lf2c, decreasing = TRUE)
    
    auto_gsea <- tryCatch({
      GSEA(geneList = gene_list_lf2c,
           TERM2GENE = TERM2GENE,
           minGSSize = minGSSize,
           maxGSSize = maxGSSize,
           pvalueCutoff = pvalueCutoff,
           pAdjustMethod = pAdjustMethod) %>%
        as.data.frame() %>%
        arrange(qvalue) %>%
        mutate(condition = condicao,
               gsea_enrichment = geneset_name)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(auto_gsea)) {
      results[[paste(condicao, geneset_name, sep = "_")]] <- auto_gsea
    }
  }
  
  final_result <- bind_rows(results) %>%
    rename(process = ID) %>%
    dplyr::select(-Description) %>%
    clean_names() %>%
    dplyr::select(condition, everything())
  
  return(final_result)
}
```



### ImmuneGO General
```{r}
# Perform GSEA

# Reactive expression to perform GSEA analyses
gsea_results_ImmuneGO_General <- reactive({
  req(input$go_2)
  req(degs_sig())
  
  degs_sig = degs_sig()
  
  # Perform ORA for ImmuneGO general
  degs_GSEA_ImmuneGO_General <- degs_sig %>%
  dplyr::select(condition, genes, log2fold_change) %>% 
  autoGSEA(TERM2GENE = ImmuneGO_genes_general, 
           geneset_name = "ImmuneGO General",
           minGSSize = input$minGSSize,
           maxGSSize = input$maxGSSize,
           pvalueCutoff = input$pvalueCutoff_gsea,
           pAdjustMethod = input$pAdjustMethod) 
})

# Render the DataTable
renderDT({
  req(input$go_2)
  req(gsea_results_ImmuneGO_General())
  gsea_results_ImmuneGO_General() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```


### ImmuneGO specific
```{r}
# Perform GSEA

# Reactive expression to perform GSEA analyses
gsea_results_ImmuneGO_genes_specific <- reactive({
  req(input$go_2)
  req(degs_sig())
  
  degs_sig = degs_sig()
  
  # Perform ORA for ImmuneGO general
  degs_GSEA_ImmuneGO_genes_specific <- degs_sig %>%
  dplyr::select(condition, genes, log2fold_change) %>% 
  autoGSEA(TERM2GENE = ImmuneGO_genes_specific, 
           geneset_name = "ImmuneGO General",
           minGSSize = input$minGSSize,
           maxGSSize = input$maxGSSize,
           pvalueCutoff = input$pvalueCutoff_gsea,
           pAdjustMethod = input$pAdjustMethod) 
})

# Render the DataTable
renderDT({
  req(input$go_2)
  req(gsea_results_ImmuneGO_genes_specific())
  gsea_results_ImmuneGO_genes_specific() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```



### CellMarker immune
```{r}
# Perform GSEA

# Reactive expression to perform GSEA analyses
gsea_results_CellMarker <- reactive({
  req(input$go_2)
  req(degs_sig())
  
  degs_sig = degs_sig()
  
  # Perform ORA for ImmuneGO general
  degs_GSEA_CellMarker <- degs_sig %>%
  dplyr::select(condition, genes, log2fold_change) %>% 
  autoGSEA(TERM2GENE = CellMarker_genes, 
           geneset_name = "CellMarker immune",
           minGSSize = input$minGSSize,
           maxGSSize = input$maxGSSize,
           pvalueCutoff = input$pvalueCutoff_gsea,
           pAdjustMethod = input$pAdjustMethod) 
})

# Render the DataTable
renderDT({
  req(input$go_2)
  req(gsea_results_CellMarker())
  gsea_results_CellMarker() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```


### BTM immune
```{r}
# Perform GSEA

# Reactive expression to perform GSEA analyses
gsea_results_BTM_Immune  <- reactive({
  req(input$go_2)
  req(degs_sig())
  
  degs_sig = degs_sig()
  
  # Perform ORA for ImmuneGO general
  degs_GSEA_BTM_Immune <- degs_sig %>%
  dplyr::select(condition, genes, log2fold_change) %>% 
  autoGSEA(TERM2GENE = btm_genes, 
           geneset_name = "BTM Immune",
           minGSSize = input$minGSSize,
           maxGSSize = input$maxGSSize,
           pvalueCutoff = input$pvalueCutoff_gsea,
           pAdjustMethod = input$pAdjustMethod) 
})

# Render the DataTable
renderDT({
  req(input$go_2)
  req(gsea_results_BTM_Immune())
  gsea_results_BTM_Immune() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```



### Vax MSigDB
```{r}
# Perform GSEA

# Reactive expression to perform GSEA analyses
gsea_results_VaxSigDB_Genes_filtered <- reactive({
  req(input$go_2)
  req(degs_sig())
  
  degs_sig = degs_sig()
  
  # Perform ORA for ImmuneGO general
  degs_GSEA_VaxSigDB_Genes_filtered <- degs_sig %>%
  dplyr::select(condition, genes, log2fold_change) %>% 
  autoGSEA(TERM2GENE = VaxSigDB_Genes_filtered, 
           geneset_name = "VaxSigDB Filtered",
           minGSSize = input$minGSSize,
           maxGSSize = input$maxGSSize,
           pvalueCutoff = input$pvalueCutoff_gsea,
           pAdjustMethod = input$pAdjustMethod) 
})

# Render the DataTable
renderDT({
  req(input$go_2)
  req(gsea_results_VaxSigDB_Genes_filtered())
  gsea_results_VaxSigDB_Genes_filtered() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})
```


# ssGSEA (Comming soon)

## Column {.sidebar data-width=400}

**Upload your data**

```{r}

fileInput(inputId = "ssgsea_gene", 
          label = "Normalized counts",
           accept = ".csv")

fileInput(inputId = "metadata", 
          label = "Sample annotations",
           accept = ".csv")
```

## Column
### ssGSEA - Corto package
```{r}
# Carregamento e processamento dos dados
ssgsea_results_ImmuneGO_General <- reactive({
  req(input$go_3)  # Certifique-se de que o botão de ação foi pressionado
  req(input$ssgsea_gene, input$metadata)  # Certifique-se de que os arquivos foram carregados

  # Ler os arquivos carregados
  expression_data <- read.csv(input$ssgsea_gene$datapath, row.names = 1)
  metadata <- read.csv(input$metadata$datapath)

  # Obter os nomes das amostras
  sample_names <- colnames(expression_data) %>% 
    as.data.frame() %>% 
    rename(sample_names = '.')

  # ImmuneGO General
  genelist_immunego_general <- ImmuneGO_genes_general %>%
   dplyr::select(process, genes) %>% 
    split(.$genes, .$process)

  # Calcular ssGSEA
  nesmat_result_immunego_general <- ssgsea(inmat = expression_data, 
                                           groups = genelist_immunego_general) %>% 
    as.data.frame() %>% 
    t() %>% 
    as.data.frame() %>% 
    rownames_to_column("sample") %>% 
    relocate(sample, .before = everything()) %>% 
    cbind(sample_names) %>% 
   dplyr::select(-sample) %>% 
    column_to_rownames("sample_names") %>% 
    t() %>% 
    as.data.frame() %>% 
    rownames_to_column("process") %>% 
    relocate(process, .before = everything()) %>% 
    pivot_longer(cols = -process, names_to = "sample", values_to = "nes") %>%
    mutate(pvalue = z2p(nes), # Converter NES para p-value
           qvalue = p.adjust(pvalue, method = "BH"),
           logq = -log10(qvalue),
           geneset_name = "ImmuneGO General") %>%
    merge(metadata, by = "sample", all.x = TRUE) %>%
    merge(ImmuneGO_genes_general, by = "process", all.x = TRUE) %>%
   dplyr::select(-genes) %>%
    distinct()
  
  return(nesmat_result_immunego_general)
})

# Renderizar o DataTable
renderDT({
  req(input$go_2)
  req(ssgsea_results_ImmuneGO_General())
  ssgsea_results_ImmuneGO_General() %>% 
    datatable(extensions = 'Buttons',
              options = list(
                paging = TRUE,
                searching = TRUE,
                fixedColumns = TRUE,
                autoWidth = TRUE,
                ordering = TRUE,
                dom = 'Blfrtip',
                buttons = c('copy', 'csv', 'excel')
              ),
              class = "display"
    )
})
```



```{r eval=FALSE, include=FALSE}
############## Inputs

fileInput(inputId = "ssgsea_gene", 
          label = "Upload your normalized counts",
           accept = ".csv")

fileInput(inputId = "metadata", 
          label = "Upload sample annotations",
           accept = ".csv")


ssgsea_results_ImmuneGO_General <- reactive({
  req(input$go_3)
  req(input$ssgsea_gene)
  req(input$metadata)
  
  
  sample_names = input$ssgsea_gene %>% 
  as.data.frame() %>% 
  colnames() %>% 
  as.data.frame() %>% 
  rename(sample_names = '.')
  
  
  #ImmuneGO General -------
genelist_immunego_general = ImmuneGO_genes_general %>%
 dplyr::select(process, genes) %>% 
  filter(!process %in% c("TCR REPERTOIRE", "BCR REPERTOIRE"))
genelist_immunego_general = split(genelist_immunego_general$genes, genelist_immunego_general$process) 


nesmat_result_immunego_general = ssgsea(inmat = input$ssgsea_gene , 
                                        groups = genelist_immunego_general) %>% 
  as.data.frame() %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column("sample") %>% 
  relocate(sample, .before = everything()) %>% 
  cbind(sample_names) %>% 
 dplyr::select(-sample) %>% 
  column_to_rownames("sample_names") %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column("process") %>% 
  relocate(process, .before=everything()) %>% 
  pivot_longer(cols = -process, names_to = "sample", values_to = "nes") %>%
  mutate(pvalue = z2p(nes), #Convert NES into pvalue
         qvalue = p.adjust(pvalue, method = "BH"),
         logq = - log10(qvalue),
         geneset_name = "ImmuneGO General") %>%
  merge(metadata, by= "sample", all.x=T) %>%
  merge(ImmuneGO_genes_general, by = "process", all.x=T) %>% 
 dplyr::select(!genes) %>% 
  distinct()
})


# Render the DataTable
renderDT({
  req(input$go_2)
  req(ssgsea_results_ImmuneGO_General())
  ssgsea_results_ImmuneGO_General() %>% 
  datatable(extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = TRUE,
                                ordering = TRUE,
                                dom = 'Blfrtip',
                                buttons = c('copy', 'csv', 'excel')
                            ),

                            class = "display"
                       )
})

```



# Gene Overlap (multiple conditions)

## Column {.sidebar data-width=300}

**Filters**
```{r}
############## Filters 

# DGE analysis
numericInput(inputId = "filter_padj_overlap", 
             label = "Adjusted p-value cutoff", 
             value = 0.05, 
             min = 0, max = 1, step = 0.01)

numericInput(inputId = "filter_logfc_overlap", 
             label = "Log2 Fold Change cutoff", 
             value = 1, 
             min = 0, max = 10, step = 0.1)


checkboxInput(inputId = "overlap_metric", 
                   label = "Overlap method", 
                   choices = c("jaccard_distance",
                               "Shared"))

actionButton("go_overlap", "Go")
```


## Column {.tabset .tabset-fade}

```{r include=FALSE}
# Function for overlapping -------
overlap_genes <- function(cond1, cond2, data) {
  genes_cond1 <- data$genes[data$process == cond1]
  genes_cond2 <- data$genes[data$process == cond2]
  
  genes_shared <- intersect(genes_cond1, genes_cond2)
  
  genes_notshared_cond1 <- setdiff(genes_cond1, genes_cond2)
  genes_notshared_cond2 <- setdiff(genes_cond2, genes_cond1)
  
  total_genes_cond1 <- length(genes_cond1)
  total_genes_cond2 <- length(genes_cond2)
  
  percentage_shared_cond1 <- length(genes_shared) / total_genes_cond1 * 100
  percentage_shared_cond2 <- length(genes_shared) / total_genes_cond2 * 100
  
  shared_genes <- data.frame(
    Cond1 = cond1,
    Cond2 = cond2,
    Shared = length(genes_shared),
    NotShared_cond1 = length(genes_notshared_cond1),
    NotShared_cond2 = length(genes_notshared_cond2),
    Total_Genes_Cond1 = total_genes_cond1,
    Total_Genes_Cond2 = total_genes_cond2,
    Genes_Names = paste(genes_shared, collapse = ", "),
    Percentage_Shared_Cond1 = percentage_shared_cond1,
    Percentage_Shared_Cond2 = percentage_shared_cond2
  )
  
  return(shared_genes)
}


# Fisher's exact test
fisher_exact_test <- function(shared, notshared1, notshared2) {
  cont_table <- matrix(c(shared, notshared1, notshared2, 0), nrow = 2)
  results_fisher <- fisher.test(cont_table)
  return(results_fisher$p.value)
}

```

### All DEGs

```{r}
df <- reactive({
  req(input$go_overlap)
  req(conditions_genes())
  
  conditions_genes() %>%
    filter(log2fold_change >= input$filter_logfc_overlap | log2fold_change <= - input$filter_logfc_overlap,
           padj < input$filter_padj_overlap) %>% 
    dplyr::select(process = condition, genes)
})

# Reactive expression to compute GO enrichment results
overlap_results <- reactive({
  req(input$go_overlap)
  req(df())

  # Initialize variables
  unique_cond <- unique(df()$process) # List of unique conditions
  shared_genes_df <- data.frame() # Data frame to store shared gene results

  # Compute overlap between conditions
  for (i in 1:(length(unique_cond) - 1)) {
    for (j in (i + 1):length(unique_cond)) {
      resultado_temp <- overlap_genes(unique_cond[i], unique_cond[j], df())
      shared_genes_df <- bind_rows(shared_genes_df, resultado_temp)
    }
  }

  # Compute Fisher's exact test p-values
  shared_genes_df <- shared_genes_df %>%
    mutate(pvalue = pmap_dbl(list(Shared, NotShared_cond1, NotShared_cond2), fisher_exact_test)) %>% 
    mutate("-log(p)" = -log10(pvalue))

  # Create mirror table
  shared_genes_df_mirror <- shared_genes_df %>% 
    rename(Cond1_temp = Cond1, Cond2_temp = Cond2) %>%
    rename(Cond1 = Cond2_temp, Cond2 = Cond1_temp) %>%
    bind_rows(shared_genes_df) %>%
    mutate(Percentage_Shared_Cond1 = round(Percentage_Shared_Cond1, 2),
           Percentage_Shared_Cond2 = round(Percentage_Shared_Cond2, 2))
  
  # Calculate Jaccard distance matrix
  jaccard.matrix <- df() %>%
    mutate(present = 1) %>% 
    distinct() %>% 
    pivot_wider(names_from = genes, values_from = present, values_fill = 0) %>%
    column_to_rownames(var = "process") %>%
    vegdist(binary = TRUE, method = "jaccard", diag = TRUE, upper = TRUE) %>%
    as.matrix() %>%
    {1 - .}

  # Combine Jaccard distance with shared genes data
  shared_genes_df_mirror <- jaccard.matrix %>% 
    as.data.frame() %>% 
    rownames_to_column("Cond1") %>% 
    pivot_longer(cols = -"Cond1", names_to = "Cond2", values_to = "jaccard_distance") %>% 
    inner_join(shared_genes_df_mirror, by = c("Cond1", "Cond2")) %>% 
    mutate(jaccard_distance = round(jaccard_distance, 3))
  
  return(shared_genes_df_mirror)
})

# Render the final results in a DataTable
DT::renderDataTable({
  req(input$go_overlap)
  req(overlap_results())
  
  
  overlap_results() %>% 
    datatable(extensions = 'Buttons',
              options = list(
                paging = TRUE,
                searching = TRUE,
                fixedColumns = TRUE,
                autoWidth = TRUE,
                ordering = TRUE,
                dom = 'Blfrtip',
                buttons = c('copy', 'csv', 'excel')
              ),
              class = "display"
    )
})
```

### Only immune genes

```{r}
df_immune <- reactive({
  req(input$go_overlap)
  req(conditions_genes())
  
  conditions_genes() %>%
    filter(log2fold_change >= input$filter_logfc_overlap | 
             log2fold_change <= - input$filter_logfc_overlap,
           padj < input$filter_padj_overlap) %>% 
    dplyr::select(process = condition, genes) %>% 
    inner_join(ImmuneGO_genes_general %>% dplyr::select(genes) %>% distinct(), 
               by = "genes")
})

# Reactive expression to compute GO enrichment results
overlap_results_immune <- reactive({
  req(input$go_overlap)
  req(df_immune())

  # Initialize variables
  unique_cond <- unique(df()$process) # List of unique conditions
  shared_genes_df <- data.frame() # Data frame to store shared gene results

  # Compute overlap between conditions
  for (i in 1:(length(unique_cond) - 1)) {
    for (j in (i + 1):length(unique_cond)) {
      resultado_temp <- overlap_genes(unique_cond[i], unique_cond[j], df_immune())
      shared_genes_df <- bind_rows(shared_genes_df, resultado_temp)
    }
  }

  # Compute Fisher's exact test p-values
  shared_genes_df <- shared_genes_df %>%
    mutate(pvalue = pmap_dbl(list(Shared, NotShared_cond1, NotShared_cond2), fisher_exact_test)) %>% 
    mutate("-log(p)" = -log10(pvalue))

  # Create mirror table
  shared_genes_df_mirror <- shared_genes_df %>% 
    rename(Cond1_temp = Cond1, Cond2_temp = Cond2) %>%
    rename(Cond1 = Cond2_temp, Cond2 = Cond1_temp) %>%
    bind_rows(shared_genes_df) %>%
    mutate(Percentage_Shared_Cond1 = round(Percentage_Shared_Cond1, 2),
           Percentage_Shared_Cond2 = round(Percentage_Shared_Cond2, 2))
  
  # Calculate Jaccard distance matrix
  jaccard.matrix <- df() %>%
    mutate(present = 1) %>% 
    distinct() %>% 
    pivot_wider(names_from = genes, values_from = present, values_fill = 0) %>%
    column_to_rownames(var = "process") %>%
    vegdist(binary = TRUE, method = "jaccard", diag = TRUE, upper = TRUE) %>%
    as.matrix() %>%
    {1 - .}

  # Combine Jaccard distance with shared genes data
  shared_genes_df_mirror <- jaccard.matrix %>% 
    as.data.frame() %>% 
    rownames_to_column("Cond1") %>% 
    pivot_longer(cols = -"Cond1", names_to = "Cond2", values_to = "jaccard_distance") %>% 
    inner_join(shared_genes_df_mirror, by = c("Cond1", "Cond2")) %>% 
    mutate(jaccard_distance = round(jaccard_distance, 3))
  
  return(shared_genes_df_mirror)
})

# Render the final results in a DataTable
DT::renderDataTable({
  req(input$go_overlap)
  req(overlap_results_immune())
  
  overlap_results_immune() %>% 
    datatable(extensions = 'Buttons',
              options = list(
                paging = TRUE,
                searching = TRUE,
                fixedColumns = TRUE,
                autoWidth = TRUE,
                ordering = TRUE,
                dom = 'Blfrtip',
                buttons = c('copy', 'csv', 'excel')
              ),
              class = "display"
    )
})
```


### Not immune genes

```{r}
df_immune <- reactive({
  req(input$go_overlap)
  req(conditions_genes())
  
  conditions_genes() %>%
    filter(log2fold_change >= input$filter_logfc_overlap | 
             log2fold_change <= - input$filter_logfc_overlap,
           padj < input$filter_padj_overlap) %>% 
    dplyr::select(process = condition, genes) %>% 
    anti_join(ImmuneGO_genes_general %>% dplyr::select(genes) %>% distinct(), 
               by = "genes")
})

# Reactive expression to compute GO enrichment results
overlap_results_immune <- reactive({
  req(input$go_overlap)
  req(df_immune())

  # Initialize variables
  unique_cond <- unique(df()$process) # List of unique conditions
  shared_genes_df <- data.frame() # Data frame to store shared gene results

  # Compute overlap between conditions
  for (i in 1:(length(unique_cond) - 1)) {
    for (j in (i + 1):length(unique_cond)) {
      resultado_temp <- overlap_genes(unique_cond[i], unique_cond[j], df_immune())
      shared_genes_df <- bind_rows(shared_genes_df, resultado_temp)
    }
  }

  # Compute Fisher's exact test p-values
  shared_genes_df <- shared_genes_df %>%
    mutate(pvalue = pmap_dbl(list(Shared, NotShared_cond1, NotShared_cond2), fisher_exact_test)) %>% 
    mutate("-log(p)" = -log10(pvalue))

  # Create mirror table
  shared_genes_df_mirror <- shared_genes_df %>% 
    rename(Cond1_temp = Cond1, Cond2_temp = Cond2) %>%
    rename(Cond1 = Cond2_temp, Cond2 = Cond1_temp) %>%
    bind_rows(shared_genes_df) %>%
    mutate(Percentage_Shared_Cond1 = round(Percentage_Shared_Cond1, 2),
           Percentage_Shared_Cond2 = round(Percentage_Shared_Cond2, 2))
  
  # Calculate Jaccard distance matrix
  jaccard.matrix <- df() %>%
    mutate(present = 1) %>% 
    distinct() %>% 
    pivot_wider(names_from = genes, values_from = present, values_fill = 0) %>%
    column_to_rownames(var = "process") %>%
    vegdist(binary = TRUE, method = "jaccard", diag = TRUE, upper = TRUE) %>%
    as.matrix() %>%
    {1 - .}

  # Combine Jaccard distance with shared genes data
  shared_genes_df_mirror <- jaccard.matrix %>% 
    as.data.frame() %>% 
    rownames_to_column("Cond1") %>% 
    pivot_longer(cols = -"Cond1", names_to = "Cond2", values_to = "jaccard_distance") %>% 
    inner_join(shared_genes_df_mirror, by = c("Cond1", "Cond2")) %>% 
    mutate(jaccard_distance = round(jaccard_distance, 3))
  
  return(shared_genes_df_mirror)
})

# Render the final results in a DataTable
DT::renderDataTable({
  req(input$go_overlap)
  req(overlap_results_immune())
  
  overlap_results_immune() %>% 
    datatable(extensions = 'Buttons',
              options = list(
                paging = TRUE,
                searching = TRUE,
                fixedColumns = TRUE,
                autoWidth = TRUE,
                ordering = TRUE,
                dom = 'Blfrtip',
                buttons = c('copy', 'csv', 'excel')
              ),
              class = "display"
    )
})
```


## Column {data-width=1000}

### Heatmap - All DEGs
```{r}
renderPlotly({
  req(overlap_results_immune())
  
  # Prepare the data
  heatmap_data <- overlap_results_immune()
  
  # Ensure that the data is in a matrix format required by heatmaply
  heatmap_matrix <- heatmap_data %>%
    dplyr::select(Cond1, Cond2, overlap_metric) %>% 
    pivot_wider(names_from = Cond2, values_from = input$overlap_metric) %>%
    distinct() %>% 
    column_to_rownames(var = "Cond1") %>%
    as.matrix()
  
  # Create the heatmap
   # Create the heatmap
  heatmaply(heatmap_matrix,
            xlab = "Conditions",
            ylab = "Conditions",
            main = "Heatmap of Overlapped Genes",
            plot_method = "plotly",
            colors = c("white", "#FF6666")) %>%
    layout(title = "Heatmap of Overlap Results",
           xaxis = list(title = "Condition"),
           yaxis = list(title = "Condition"))
})
```


